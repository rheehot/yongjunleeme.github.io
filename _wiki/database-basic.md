---
layout  : wiki
title   : database-basic 
summary : 
date    : 2020-04-01 15:51:11 +0900
updated : 2020-04-02 19:03:20 +0900
tags    : 
toc     : true
public  : true
parent  : 
latex   : false
---
* TOC
{:toc}

## 데이터베이스

### 데이터베이스를 사용하는 이유

- 독립성 
    - 물리적 독립성: 데이터베이스 사이즈를 늘리거나 파일을 추가해도 수정할 필요가 없다.
    - 논리적 독립성: 다양한 응용 프로그램의 논리적 요구를 만족
- 무결성
    - 잘못된 데이터가 발생하는 경우의 수를 방지, 유효성 검사(데이터 타입 제어)
- 보안성
- 일관성
    - 연관된 정보를 논리적 구조로 관리해서 하나의 데이터 변경 시 발생할 불일치성을 배제
- 중복 최소화

### 데이터베이스의 성능

- 디스크 I/O을 어떻게 줄이느냐에서 시작
- 데이터 읽는 시간은 디스크 헤더가 데이터 읽고 쓰는 위치로 이등하는 단계에서 결정
- 디스크 성능은 위치 이동 없이 얼마나 많은 데이터를 1번에 기록하느냐가 결정
- 순차 I/O가 랜덤 I/O보다 빠르다. 하지만 현실에서는 보통 랜덤 I/O. 이런 랜덤 I/O 자체를 줄이는 것이 데이터베이스 쿼리 튜닝의 목적 중 하나.

## Index

### Index란 무엇인가

인덱스는 말 그대로 색인. 칼럼 값과 레코드 주소를 키와 값 쌍의 인덱스로 만듦. 인덱스는 정렬 상태를 유지하므로 값 탐색은 빠르지만 값 추가, 삭제 등의 수정문 실행 속도는 느리다. 이는 저장 성능을 희생하고 대신 데이터 읽기 속도를 높이는 기능.

- SortedLIst는 인덱스와 같은 자료구조, ArrayList는 데이터 파일과 같은 자료구조
- SortedList는 저장된 값을 항상 정렬된 상태로 유지, ArrayList는 저장되는 순대대로 유지
- 인덱스도 마찬가지로 컬럼의 값을 이용해 정렬된 상태 유지, 데이터 파일은 ArrayList와 같이 저장된 순서대로 정렬 없이 저장
- SortedList는 데이터가 저장될 때마다 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리다. 그러나 이미 정렬돼 있으므로 빠르게 원하는 값을 부를 수 있다. 
- DBMS의 인덱스도 인덱스가 많은 테이블은 INSERT, UPDATE, DELETE 처리가 느리다. 하지만 SELECT는 빠르게 처리

### Index 자료구조

#### [B+-Tree 인덱스 알고리즘](https://12bme.tistory.com/138)

보통 사용되는 인덱스 알고리즘. 칼럼의 값을 변형하지 않고(사실 앞부분만 잘라서 관리) 원래의 값을 이용해 인덱싱하는 알고리즘

#### Hash 인덱스 알고리즘

컬럼 값으로 해시 값을 계산해 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로 특정 문자로 시작하는 값을 검색하는 등 값의 일부만 검색할 때는 해시 인덱스를 사용할 수 없다. 주로 메모리 기반의 데이터베이스에서 많이 사용.

#### 왜b-tree를 사용?

데이터 접근 시간복잡도가 O(1)인 hash table이 더 효율적이지 않을까? SELECT 질의 조건에는 부등호(<>) 연산이 포함되므로 Hash table을 사용하면 등호(=) 연산이 아닌 부등호 연산에서 문제가 발생한다. 동등 연산(=)에 특화된 Hashtablse은 데이터베이스의 자료구조로 부적합하다.

### Primary Index vs Secondary Index

인덱스에서 클러스터는 비슷한 것들을 묶어서 저장하는 형태로 구현. 주로 비슷한 값을 동시에 조회하는 사례가 많다는 점에서 착안. 여기서 비슷한 값들은 물리적으로 인접한 장소에 저장된 데이터들을 말한다.

클러스터드 인덱스는 테이블의 프라이머리 키에 적용. 즉, 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터드 인덱라고 표현. 프라이머리 키 값에 의해 저장 위치가 결정. 프라이머리 키 값이 변경되 그 레코드의 물리적인 저장 위치도 변경되어야.

클러스터드 인덱스는 테이블당 1개만 생성 가능하다. 프라이머리 키에 대해서만 적용되기 때문이다. 이에 반 Non클러스터드 인덱스는 테이블당 여러 개 생성 가능.

### Composite Index

인덱스로 설정하는 필드의 속성이 중요. 예를 들어, title, author 순서대로 인덱스를 설정한다면 title을 검색하는 경우, 인덱스를 생성한 효과를 볼 수 있다. 반면에 author만으로 검색한다면 인덱스 생성이 소용 없어진다. 따라서 SELECT 질의를 어떻게 정할 것인가 인덱스 생성 방법에 많은 영향을 끼치는 것이다.

### Index의 성능과 고려사항

SELECT 쿼리 성능을 월등히 향상시키는 인덱스는 항상 좋은 것일까? 그렇지 않다. 인덱스를 생성하면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도 과정이 필요하게 된다. INSERT는 인덱스 데이터도 추가해야 하므로 성능 손실, DELETE는 인덱스에 존재하는 값은 삭제하지 않고 사용 안 한다는 표시를 남긴다. 즉 Row 수는 그대로다. UPDATE는 INSERT와DELETE 모두의 문제점이 동시에 발생한다. 이전 데이터를 삭제하고 그 자리에 새로운 데이터를 생성하는 개념이기 때문이다. 즉 변경 전 데이터는 삭제되지 않고 INSERT로 인한 SPLIT도 발생한다.

이름, 나이, 성별 필드의 테이블을 생각해보자. 이름은 여러 경우의 수가 존재할 것이고 나이는 INT 성별은 몇 가지 데이터만 존재할 것이다. 이 경우에는 이름에 관해서만 인덱스를 생성해야 효율적이다. 
왜 나이와 성별은 비효율적일까? 10000개 레코드에 해당하는 테이블에 대해2000 단위로 성별에 인덱스를 생성했다고 가정한다면 값의 range가 적은 성별은 인덱스를 읽고 다시 한 번 디스크 I/O가 발생하므로 그만큼 비효율적인 것이다.

## 정규화

### 정규화 탄생 배경

한 릴레이션에 관해 여러 엔티티의 애트리뷰트(필드)를 혼합하면 정보가 중복 저장돼 공간을 낭비. 또한 중복 정보로 인해 갱신 이상이 발생한다. 이를 해결하기 위해 정규화 과정을 거친다.

### 정규화란?

중복을 최소화하기 위해 데이터를 구조화하는 작업. 애트리뷰트를 나눠서 작은 릴레이션으로 분해하는 것을 말한다. 정규화 과정을 거치면 정규형을 만족하게 되는데 이는 특정 조건을 만족하는 릴레이션의 스키마 형태를 뜻한다. 1 정규형, 2 정규형, 3 정규형 등이 있다.

#### 나쁜 릴레이션은 어떻게 판단?

엔티티를 구성하는 애트리뷰트 간 함수적 종속성(Functional Dependency)를 판단. 이는 좋은 릴레이션 설계의 정형적 기준으로 사용.

#### 함수적 종속성이란?

애트리뷰트 데이터들의 의미와 애트리뷰트들 간의 상호 관계로부터 유도되는 제약조건의 일종. XX와 Y를 임의 애트리뷰 집합이라고 할 때, X의 값이 Y의 값을 유일하게(Unique) 결정한다면 "X는 Y를 함수적으로 결정한다"라고 한다. 각종 추론 규칙에 따라 애트리뷰트들 간의 함수적 종속성을 판단할 수 있다. cf) 애트리튜트들의 관계로부터 추론된 함수적 종속성들을 기반으로 추론 가능한 모든 함수적 종속성들의 집합을 폐포라고 한다.

#### 각각의 정규형은 어떤 조건을 만족해야 하는가?

1. 분해의 대상인 분해 집합 D는 무손실 조인을 보장해야 한다.
2. 분해 집합 D는 함수적 종속성을 보존해야 한다.

### 정규화 종류

#### 제 1 정규형

애트리뷰트의 도메인이 오직 원자값만을 포함하고, 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야 한다. 즉, 복합 애트리뷰, 다중값 애트리뷰트, 중첩 릴레이션 등 비원자적인 애트리뷰트들을 허용하지 않는 릴레이션 형태를 말한다.

#### 제 2 정규형

제 1 정규만 만족하는 릴레이션에서 부분 함수 종속성을 가지면 삽입이상, 갱신이상, 삭제이상 현상이 나타난다.
제 1 정규형에 속하면서 기본키가 아닌 모든 속성이 기본키에 완전함수 종속되면 제 2 정규형이다.


[정규화참고 블로그](https://yaboong.github.io/database/2018/03/09/database-normalization-1/)

### 정규화 장단




## Link 

- [Interview_Question_for_Beginner](https://github.com/yongjunleeme/Interview_Question_for_Beginner)

---
layout  : wiki
title   : database-basic 
summary : 
date    : 2020-04-01 15:51:11 +0900
updated : 2020-04-10 16:51:37 +0900
tags    : 
toc     : true
public  : true
parent  : 
latex   : false
---
* TOC
{:toc}

## 데이터베이스

### 데이터베이스를 사용하는 이유

- 독립성 
    - 물리적 독립성: 데이터베이스 사이즈를 늘리거나 파일을 추가해도 수정할 필요가 없다.
    - 논리적 독립성: 다양한 응용 프로그램의 논리적 요구를 만족
- 무결성
    - 잘못된 데이터가 발생하는 경우의 수를 방지, 유효성 검사(데이터 타입 제어)
- 보안성
- 일관성
    - 연관된 정보를 논리적 구조로 관리해서 하나의 데이터 변경 시 발생할 불일치성을 배제
- 중복 최소화

### 데이터베이스의 성능

- 디스크 I/O을 어떻게 줄이느냐에서 시작
- 데이터 읽는 시간은 디스크 헤더가 데이터 읽고 쓰는 위치로 이등하는 단계에서 결정
- 디스크 성능은 위치 이동 없이 얼마나 많은 데이터를 1번에 기록하느냐가 결정
- 순차 I/O가 랜덤 I/O보다 빠르다. 하지만 현실에서는 보통 랜덤 I/O. 이런 랜덤 I/O 자체를 줄이는 것이 데이터베이스 쿼리 튜닝의 목적 중 하나.

## Index

### Index란 무엇인가

인덱스는 말 그대로 색인. 칼럼 값과 레코드 주소를 키와 값 쌍의 인덱스로 만듦. 인덱스는 정렬 상태를 유지하므로 값 탐색은 빠르지만 값 추가, 삭제 등의 수정문 실행 속도는 느리다. 이는 저장 성능을 희생하고 대신 데이터 읽기 속도를 높이는 기능.

- SortedList는 인덱스와 같은 자료구조, ArrayList는 데이터 파일과 같은 자료구조
- SortedList는 저장된 값을 항상 정렬된 상태로 유지, ArrayList는 저장되는 순대대로 유지
- 인덱스도 마찬가지로 컬럼의 값을 이용해 정렬된 상태 유지, 데이터 파일은 ArrayList와 같이 저장된 순서대로 정렬 없이 저장
- SortedList는 데이터가 저장될 때마다 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리다. 그러나 이미 정렬돼 있으므로 빠르게 원하는 값을 부를 수 있다. 
- DBMS의 인덱스도 인덱스가 많은 테이블은 INSERT, UPDATE, DELETE 처리가 느리다. 하지만 SELECT는 빠르게 처리

### Index 자료구조

#### [B+-Tree 인덱스 알고리즘](https://12bme.tistory.com/138)

보통 사용되는 인덱스 알고리즘. 칼럼의 값을 변형하지 않고(사실 앞부분만 잘라서 관리) 원래의 값을 이용해 인덱싱하는 알고리즘

#### Hash 인덱스 알고리즘

컬럼 값으로 해시 값을 계산해 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로 특정 문자로 시작하는 값을 검색하는 등 값의 일부만 검색할 때는 해시 인덱스를 사용할 수 없다. 주로 메모리 기반의 데이터베이스에서 많이 사용.

#### 왜b-tree를 사용?

데이터 접근 시간복잡도가 O(1)인 hash table이 더 효율적이지 않을까? SELECT 질의 조건에는 부등호(<>) 연산이 포함되므로 Hash table을 사용하면 등호(=) 연산이 아닌 부등호 연산에서 문제가 발생한다. 동등 연산(=)에 특화된 Hashtablse은 데이터베이스의 자료구조로 부적합하다.

### Primary Index vs Secondary Index

인덱스에서 클러스터는 비슷한 것들을 묶어서 저장하는 형태로 구현. 주로 비슷한 값을 동시에 조회하는 사례가 많다는 점에서 착안. 여기서 비슷한 값들은 물리적으로 인접한 장소에 저장된 데이터들을 말한다.

클러스터드 인덱스는 테이블의 프라이머리 키에 적용. 즉, 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터드 인덱스라고 표현. 프라이머리 키 값에 의해 저장 위치가 결정. 프라이머리 키 값이 변경돼 그 레코드의 물리적인 저장 위치도 변경되어야.

클러스터드 인덱스는 테이블당 1개만 생성 가능하다. 프라이머리 키에 대해서만 적용되기 때문이다. 이에 반해 Non 클러스터드 인덱스는 테이블당 여러 개 생성 가능.

### Composite Index

인덱스로 설정하는 필드의 속성이 중요. 예를 들어, title, author 순서대로 인덱스를 설정한다면 title을 검색하는 경우, 인덱스를 생성한 효과를 볼 수 있다. 반면에 author만으로 검색한다면 인덱스 생성이 소용 없어진다. 따라서 SELECT 질의를 어떻게 정할 것인가가 인덱스 생성 방법에 많은 영향을 끼치는 것이다.

### Index의 성능과 고려사항

SELECT 쿼리 성능을 월등히 향상시키는 인덱스는 항상 좋은 것일까? 그렇지 않다. 인덱스를 생성하면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도 과정이 필요하게 된다. INSERT는 인덱스 데이터도 추가해야 하므로 성능 손실, DELETE는 인덱스에 존재하는 값은 삭제하지 않고 사용 안 한다는 표시를 남긴다. 즉 Row 수는 그대로다. UPDATE는 INSERT와DELETE 모두의 문제점이 동시에 발생한다. 이전 데이터를 삭제하고 그 자리에 새로운 데이터를 생성하는 개념이기 때문이다. 즉 변경 전 데이터는 삭제되지 않고 INSERT로 인한 SPLIT도 발생한다.

이름, 나이, 성별 필드의 테이블을 생각해보자. 이름은 여러 경우의 수가 존재할 것이고 나이는 INT 성별은 몇 가지 데이터만 존재할 것이다. 이 경우에는 이름에 관해서만 인덱스를 생성해야 효율적이다. 
왜 나이와 성별은 비효율적일까? 10000개 레코드에 해당하는 테이블에 대해2000 단위로 성별에 인덱스를 생성했다고 가정한다면 값의 range가 적은 성별은 인덱스를 읽고 다시 한 번 디스크 I/O가 발생하므로 그만큼 비효율적인 것이다.

## 정규화

### 정규화 탄생 배경

한 릴레이션에 관해 여러 엔티티의 애트리뷰트(필드)를 혼합하면 정보가 중복 저장돼 공간을 낭비. 또한 중복 정보로 인해 갱신 이상이 발생한다. 이를 해결하기 위해 정규화 과정을 거친다.

### 정규화란?

중복을 최소화하기 위해 데이터를 구조화하는 작업. 애트리뷰트를 나눠서 작은 릴레이션으로 분해하는 것을 말한다. 정규화 과정을 거치면 정규형을 만족하게 되는데 이는 특정 조건을 만족하는 릴레이션의 스키마 형태를 뜻한다. 1 정규형, 2 정규형, 3 정규형 등이 있다.

#### 나쁜 릴레이션은 어떻게 판단?

엔티티를 구성하는 애트리뷰트 간 함수적 종속성(Functional Dependency)를 판단. 이는 좋은 릴레이션 설계의 정형적 기준으로 사용.

#### 함수적 종속성이란?

애트리뷰트 데이터들의 의미와 애트리뷰트들 간의 상호 관계로부터 유도되는 제약조건의 일종. XX와 Y를 임의 애트리뷰 집합이라고 할 때, X의 값이 Y의 값을 유일하게(Unique) 결정한다면 "X는 Y를 함수적으로 결정한다"라고 한다. 각종 추론 규칙에 따라 애트리뷰트들 간의 함수적 종속성을 판단할 수 있다. cf) 애트리트들의 관계로부터 추론된 함수적 종속성들을 기반으로 추론 가능한 모든 함수적 종속성들의 집합을 폐포라고 한다.

#### 각각의 정규형은 어떤 조건을 만족해야 하는가?

1. 분해의 대상인 분해 집합 D는 무손실 조인을 보장해야 한다.
2. 분해 집합 D는 함수적 종속성을 보존해야 한다.

### 정규화 종류

#### 제 1 정규형

애트리뷰트의 도메인이 오직 원자값만을 포함하고, 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야 한다. 즉, 복합 애트리뷰, 다중값 애트리뷰트, 중첩 릴레이션 등 비원자적인 애트리뷰트들을 허용하지 않는 릴레이션 형태를 말한다.

#### 제 2 정규형

제 1 정규만 만족하는 릴레이션에서 부분 함수 종속성을 가지면 삽입이상, 갱신이상, 삭제이상 현상이 나타난다.
제 1 정규형에 속하면서 기본키가 아닌 모든 속성이 기본키에 완전함수 종속되면 제 2 정규형이다.

#### 제 3 정규형

제 2 정규형에 속하면서, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제 3 정규형이다.

- 이행적 함수 종속(Transitive Functional Dependency)
삼ㄴ단논법 같은 관계를 가진 함수종속이다. X, Y, Z에 대해 X -> Y이고 Y -> Z이면 X -> Z가 성립한다. 이를 Z가 X에 이행적으로 함수 종속되었다고 한다.

- [정규화참고 블로그](https://yaboong.github.io/database/2018/03/09/database-normalization-1/)

#### BCNF(Boyce-code) 정규형

여러 후보키가 존재하는 릴레이션에 해당하는 정규화 내용. 비주요 애트리뷰트가 후보키의 일부를 결정해 분해하는 과정을 말한다.

- 모든 제 2 정규형 릴레이션은 제 1 정규형을 갖는다.
- 모든 제 3 정규형 릴레이션은 제 2 정규형을 갖는다.
- 모든 BCNF 정규형 릴레이션은 제 3 정규형을 갖는다.

수많은 정규형이 있지만 관계 데이터베이스 설계의 목표는 각 릴레이션이 3NF(or BCNF)를 갖게 하는 것이다.

## 트랜잭션

### 트랜잭션은 무엇인가?

트랜잭션은 하나의 논리적 작업단위를 구성하는 일련의 연산들의 집합니다. 특징은 작업의 완전성을 보장해준다는 것이다. 논리적인 작업 셋 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다.

### 트랜잭션과 Lock

잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하는 기능이다. 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청하면 한 시점에서는 하나의 커넥션만 변경할 수 있도록 하는 역할이다. 여기서 자원은 레코드나 테이블을 말한다. 이와는 다르게 트랜잭션이 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합됐을 때만 의미있는 개념은 아니다. 트랜잭션은 하나의 논리적인 작업 셋 중 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가  적용되거나 아무것도 적용되지 않아야 함을 보장하는 것이다. 예를 들면 HW 에러 또는 SW 에러와 같은 문제로 인해 작업에 실패가 있는 경우, 특별한 대책이 필요한데 이러한 문제를 해결하는 것이다.

### 트랜잭션의 특성

#### 원자성(Atomicity)

만약 트랜잭션 중간에 어떤 문제가 발생한다면 작업을 수행하지 않고 아무런 문제가 발생하지 않아야 모든 작업을 수행한다. 쉽게 'All or nothing' 특성으로 설명된다.

#### 일관성(Consistency)

트랜잭션이 완료된 다음 상태에서도 트랜잭션이 일어나기 전 상황과 동일하게 데이터의 일관성을 보장해야 한다.
고립된 트랜잭션의 수행이 데이터베이스의 일관성을 보존해야 한다. 즉, 성공적으로 수행된 트랜잭션은 정당한 데이터들만을 데이터베이스에 반영해야 한다. 트랜잭션의 수행을 데이터베이스 상태 간의 전이(Transition)로 봤을 떄, 트랜잭션 수행 전후의 데이터베이스 상태는 각각 일관성이 보장되는 서로 다른 상태가 도니다. 트랜잭션 수행이 보존해야 할 일관성은 기본 키, 외래 키 제약과 같은 명시적인 무결성 제약 조건들뿐만 아니라, 자금 이체 예ㅔ에서 두 계좌 잔고의 합은 이체 전후가 같아야 한다는 사항과 같은 비명시적인 일관성 조건들도 있다.

#### 독립성(Isolation)

각각의 트랜잭션은 서로 간섭없이 독립적으로 수행
여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션의 수행에 영향을 받지 않고 독립적으로 수행되어야 한다. 즉, 한 트랜잭션의 중간 결과가 다른 트랜잭션에게는 숨겨져야 한다는 의미인데, 이러한 Isolation 성질이 보장되지 않으면 트랜잭션이 원래 상태로 되돌아갈 수 없게 된다. Isolation 성질을 보장할 가장 쉬운 방법은 모든 트랜잭션을 순차적으로 수행하는 것이다. 하지만 병렬적 수행의 장점을 얻기 위해 DBMS는 병렬적으로 수행하면서도 일렬(Serial) 수행과 같은 결과를 보장할 방식을 제공하고 있다.

#### 지속성(Durability)

트랜잭션이 정상 종료된 후에는 영구적으로 데이터베이스에 작업 결과가 저장돼야 한다.

### 트랜잭션 사용 시 주의할 점

트랜잭션은 꼭 필요한 최소한 코드에만 적용하는 것이 좋다. 즉 트랜잭션의 범위를 최소화하라는 의미다. 일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있는 것이다.


### Reference

- [DBMS는 어떻게 트랜잭션을 관리할까?](https://d2.naver.com/helloworld/407507)


## Link 

- [Interview_Question_for_Beginner](https://github.com/yongjunleeme/Interview_Question_for_Beginner)
